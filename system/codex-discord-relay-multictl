#!/usr/bin/env bash
set -euo pipefail

DEFAULT_ENV_FILE="${CODEX_RELAY_ENV_FILE:-/root/.codex-discord-relay.env}"
DEFAULT_STATE_DIR="${CODEX_RELAY_STATE_DIR:-/root/.codex-discord-relay}"
INSTANCES_ENV_DIR="${CODEX_RELAY_INSTANCES_ENV_DIR:-$DEFAULT_STATE_DIR/instances.d}"
INSTANCES_STATE_ROOT="${CODEX_RELAY_INSTANCES_STATE_ROOT:-$DEFAULT_STATE_DIR/instances}"

ENSURE="/usr/local/bin/codex-discord-relay-ensure-multi.sh"

usage() {
  cat <<USAGE
Usage: codex-discord-relay-multictl <command> [args]

Commands:
  list                           List instances (default)
  status [name|all]              Status of one instance (or all)
  start [name|all]               Start/ensure one instance (or all)
  stop [name|all]                Stop one instance (or all)
  restart [name|all]             Restart one instance (or all)
  logs <name>                    Tail logs for an instance

Instances:
  - default: $DEFAULT_ENV_FILE (state: $DEFAULT_STATE_DIR)
  - extra:   $INSTANCES_ENV_DIR/<name>.env (state: $INSTANCES_STATE_ROOT/<name>)

Restart safety:
  - restart is blocked when target instance state contains active runs
    (conversation agentRun.status=running)
  - override once (unsafe): CODEX_RELAY_RESTART_FORCE=1 codex-discord-relay-multictl restart <name|all>
USAGE
}

instances() {
  # Print instance names, one per line.
  if [[ -f "$DEFAULT_ENV_FILE" ]]; then
    echo "default"
  fi
  if [[ -d "$INSTANCES_ENV_DIR" ]]; then
    shopt -s nullglob
    for f in "$INSTANCES_ENV_DIR"/*.env; do
      b="$(basename "$f")"
      echo "${b%.env}"
    done
    shopt -u nullglob
  fi
}

env_file_for() {
  local name="$1"
  if [[ "$name" == "default" ]]; then
    echo "$DEFAULT_ENV_FILE"
  else
    echo "$INSTANCES_ENV_DIR/$name.env"
  fi
}

state_dir_for() {
  local name="$1"
  if [[ "$name" == "default" ]]; then
    echo "$DEFAULT_STATE_DIR"
  else
    echo "$INSTANCES_STATE_ROOT/$name"
  fi
}

running_pid_for() {
  local name="$1"
  local state_dir pid_file pid
  state_dir="$(state_dir_for "$name")"
  pid_file="$state_dir/relay.pid"

  if [[ -f "$pid_file" ]]; then
    pid="$(cat "$pid_file" 2>/dev/null || true)"
    if [[ "$pid" =~ ^[0-9]+$ ]] && kill -0 "$pid" 2>/dev/null; then
      echo "$pid"
      return 0
    fi
  fi

  # Best-effort: only safe if processes were started with --instance.
  pid="$(pgrep -f "node .*codex-discord-relay/relay.js --instance ${name}" | head -n1 || true)"
  if [[ -n "$pid" ]]; then
    echo "$pid"
    return 0
  fi
  return 1
}

running_agent_runs_for() {
  local name="$1"
  local state_dir sessions_file
  state_dir="$(state_dir_for "$name")"
  sessions_file="$state_dir/sessions.json"
  [[ -f "$sessions_file" ]] || return 0

  python3 - "$sessions_file" <<'PY'
import json
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as fh:
        obj = json.load(fh)
except Exception:
    print("__STATE_PARSE_ERROR__")
    raise SystemExit(0)

sessions = obj.get("sessions", obj if isinstance(obj, dict) else {})
if not isinstance(sessions, dict):
    raise SystemExit(0)

for conversation_key, session in sessions.items():
    if not isinstance(session, dict):
        continue
    agent_run = session.get("agentRun")
    if not isinstance(agent_run, dict):
        continue
    status = str(agent_run.get("status") or "").strip().lower()
    if status != "running":
        continue
    started_at = str(agent_run.get("startedAt") or agent_run.get("queuedAt") or "")
    provider = str(agent_run.get("provider") or "")
    reason = str(agent_run.get("reason") or "")
    print(f"{conversation_key}\t{started_at}\t{provider}\t{reason}")
PY
}

restart_guard_for_instance() {
  local name="$1"
  local rows state_dir sessions_file
  state_dir="$(state_dir_for "$name")"
  sessions_file="$state_dir/sessions.json"
  rows="$(running_agent_runs_for "$name" || true)"
  [[ -n "$rows" ]] || return 0

  if grep -qx "__STATE_PARSE_ERROR__" <<<"$rows"; then
    echo "relay[$name] restart blocked: unable to parse state file: $sessions_file" >&2
    return 1
  fi

  echo "relay[$name] restart blocked: active conversation run(s) detected:" >&2
  while IFS=$'\t' read -r conversation started provider reason; do
    [[ -n "${conversation:-}" ]] || continue
    echo "  - conversation=$conversation status=running started=${started:-unknown} provider=${provider:-unknown} reason=${reason:-request}" >&2
  done <<<"$rows"
  return 1
}

check_restart_guard() {
  local target="${1:-all}"
  local blocked=0 name

  if [[ "${CODEX_RELAY_RESTART_FORCE:-0}" == "1" ]]; then
    echo "warning: bypassing restart drain guard (CODEX_RELAY_RESTART_FORCE=1)" >&2
    return 0
  fi

  if [[ "$target" == "all" || -z "$target" ]]; then
    while IFS= read -r name; do
      [[ -n "$name" ]] || continue
      if ! restart_guard_for_instance "$name"; then
        blocked=1
      fi
    done < <(instances)
  else
    if ! restart_guard_for_instance "$target"; then
      blocked=1
    fi
  fi

  if [[ "$blocked" -ne 0 ]]; then
    echo "Refusing restart to avoid interrupting active runs." >&2
    echo "Wait for runs to finish, or cancel/reset affected conversations first." >&2
    echo "Override once (unsafe): CODEX_RELAY_RESTART_FORCE=1 codex-discord-relay-multictl restart ${target:-all}" >&2
    return 1
  fi
  return 0
}

cmd="${1:-list}"
arg="${2:-all}"

if [[ "${CODEX_DISCORD_RELAY:-}" == "1" || "${CODEX_DISCORD_RELAY_CHILD:-}" == "1" ]]; then
  case "$cmd" in
    stop|restart)
      echo "Refusing to '$cmd' codex-discord-relay instances from inside a relay-managed Codex run." >&2
      echo "Run this from SSH directly instead." >&2
      exit 3
      ;;
  esac
fi

case "$cmd" in
  list)
    printf '%-12s %-8s %-7s %s\n' "instance" "pid" "status" "state_dir"
    while IFS= read -r name; do
      state_dir="$(state_dir_for "$name")"
      if pid="$(running_pid_for "$name" 2>/dev/null)"; then
        printf '%-12s %-8s %-7s %s\n' "$name" "$pid" "running" "$state_dir"
      else
        printf '%-12s %-8s %-7s %s\n' "$name" "-" "stopped" "$state_dir"
      fi
    done < <(instances)
    ;;

  status)
    if [[ "$arg" == "all" || -z "$arg" ]]; then
      "$0" list
      exit 0
    fi
    if pid="$(running_pid_for "$arg" 2>/dev/null)"; then
      echo "relay[$arg] running pid=$pid"
    else
      echo "relay[$arg] not running"
      exit 1
    fi
    ;;

  start)
    if [[ ! -x "$ENSURE" ]]; then
      echo "missing ensure script: $ENSURE" >&2
      exit 1
    fi
    if [[ "$arg" == "all" || -z "$arg" ]]; then
      "$ENSURE"
    else
      "$ENSURE" "$arg"
    fi
    "$0" status "${arg:-all}" || true
    ;;

  stop)
    stop_one() {
      local name="$1"
      local state_dir pid_file pid
      state_dir="$(state_dir_for "$name")"
      pid_file="$state_dir/relay.pid"
      pid="$(cat "$pid_file" 2>/dev/null || true)"
      if [[ "$pid" =~ ^[0-9]+$ ]] && kill -0 "$pid" 2>/dev/null; then
        kill "$pid" || true
        rm -f "$pid_file" 2>/dev/null || true
        echo "relay[$name] stopped"
      else
        echo "relay[$name] not running"
      fi
    }
    if [[ "$arg" == "all" || -z "$arg" ]]; then
      while IFS= read -r name; do stop_one "$name"; done < <(instances)
    else
      stop_one "$arg"
    fi
    ;;

  restart)
    if ! check_restart_guard "$arg"; then
      exit 4
    fi
    if [[ "$arg" == "all" || -z "$arg" ]]; then
      "$0" stop all || true
      "$0" start all
    else
      "$0" stop "$arg" || true
      "$0" start "$arg"
    fi
    ;;

  logs)
    if [[ -z "${2:-}" ]]; then
      echo "logs requires an instance name" >&2
      exit 2
    fi
    name="$2"
    log_file="$(state_dir_for "$name")/relay.log"
    if [[ ! -f "$log_file" ]]; then
      echo "missing log: $log_file" >&2
      exit 1
    fi
    tail -n 80 "$log_file"
    ;;

  -h|--help|help)
    usage
    ;;

  *)
    usage
    exit 2
    ;;
esac
